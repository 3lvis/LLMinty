# LLMinty

Single-command CLI to emit a **token‑efficient bundle** of a Swift repository for LLMs.

- **Command:** `llminty` (no args)
- **Output:** `./minty.txt` at the repo root
- **Ignore file:** `.mintyignore` (gitignore‑style: globs, `!` negation, root‑anchored `/`, dir `/` suffix, `#` comments)
- **Deterministic:** Given the same repo + ignore rules, the output is deterministic.
- **Swift toolchain:** Swift **6.1** compatible (package pins `swift-syntax` **601.0.1**).

> This README was generated by inspecting the source in `Sources/llminty/*` and tests in `Tests/LLMintyTests/*`.

---

## Install

```bash
git clone <your fork>
cd LLMinty
swift build -c release
cp .build/release/llminty /usr/local/bin/
```

> macOS runners are recommended (the project targets macOS 13+). Linux may work with a matching Swift toolchain + `swift-syntax` release, but is not guaranteed.

---

## Usage

From the **root of the Swift repo you want to condense**:

```bash
llminty
# → prints: "Created ./minty.txt (N files)"
```

This creates a `minty.txt` file with concatenated, minimally rendered source for the most important files first.

**Output framing:** for each included file, LLMinty writes a header and a blank line, then the (possibly trimmed) content.

```
FILE: Sources/MyModule/Foo.swift

struct Foo { ... }
```

Only a **single blank** line is present after each `FILE:` header and the final file ends with a **trailing newline**.

---

## What gets included (and how)

LLMinty walks the repository, categorizes files, **ranks them**, and **renders** them to minimize tokens while preserving structure.

### Ranking signals (0–1)

Computed from lightweight AST/graph analysis (`Scoring.swift`, `GraphCentrality.swift`):

- **Graph centrality:** Fan‑in and PageRank on the file dependency graph.
- **Public API surface:** `public`/`open` symbols (protocols weighted higher).
- **Type influence:** Inbound references to declared types/protocols.
- **Complexity proxy:** Control‑flow nodes and boolean operations.
- **Entrypoint indicator:** Presence of `@main`, SwiftUI `App`, or top‑level code.

### Rendering policies

Applied per file based on score (`Rendering.swift` / `SwiftAnalyzer.swift`):

- **Swift files:** Always keep **signatures**, generics and `where` clauses. Bodies are **elided** to `{ ... }` below certain thresholds; high‑value files keep more body detail but still **condense whitespace** for stability.
- **JSON files:** Structure‑preserving reduction: keep **head 3** and **tail 2** array elements, cap **dict keys** to 6, and annotate with `// trimmed …` markers. Invalid JSON is passed through unchanged.
- **Text / unknown:** Included as‑is (size‑capped). **Binaries** are skipped.
- **Size caps:** Each file is capped at **2 MB**; common assets/bundles are excluded by default.

### Built‑in excludes

Common noise is ignored **before** user rules (you can re‑include with `!pattern` in `.mintyignore`). Examples:

- VCS/editors: `.git/`, `.gitignore`, `.gitattributes`, `.DS_Store`, `.idea/`, `.vscode/`, `.svn/`, `.hg/`
- SwiftPM: `.build/`, `.swiftpm/`
- Xcode: `DerivedData/`, `*.xcodeproj/`, `*.xcworkspace/`, `xcuserdata/`
- Apple bundles: `*.app/`, `*.appex/`, `*.framework/`, `*.dSYM/`, `*.xcarchive/`
- Dep managers: `Pods/`, `Carthage/`
- Assets/binaries: `*.xcassets/`, common image/font/archive/audio/video, `*.bin`
- **Self‑exclude:** `minty.txt`

### `.mintyignore` (optional)

Add a `.mintyignore` file at the repo root to fine‑tune inclusion. Syntax mirrors **.gitignore** (order matters; last match wins).

```gitignore
# Ignore tests and samples
Tests/
Examples/
**/*.png

# But keep golden snapshot sources
!Tests/**/Fixtures/**/*.swift
```

> Note: Use **`.mintyignore`** (not `.llmintyignore`).

---

## Developing

```bash
swift build
swift test
```

Key source files:

- `App.swift` – entrypoint wiring and top‑level flow
- `FileScanner.swift` – repo walk, file typing, size caps
- `IgnoreMatcher.swift` – gitignore‑like engine (`*` `?` `**`, `/`, `!`)
- `SwiftAnalyzer.swift` – lightweight AST passes (SwiftSyntax/SwiftParser)
- `GraphCentrality.swift` – PageRank + fan‑in
- `Scoring.swift` – feature normalization & weighted sum
- `Rendering.swift` – score‑driven trimming and canonicalization
- `JSONReducer.swift` – structure‑preserving JSON sampling
- `main.swift` – CLI bootstrap

---

## FAQ

**Does LLMinty modify my repo?**  
Only writes `minty.txt` at the root. Nothing else is changed.

**Can I keep `minty.txt` under version control?**  
Yes. Many teams commit it so LLMs (and teammates) can diff what changed.

**Does order matter?**  
Yes—files are sorted to surface the most impactful first (ranked, then by path).

**Will it run on CI?**  
Absolutely—see the CI recipe below.

---

## CI: auto‑refresh `minty.txt` on every change

The recommended approach is a **GitHub Actions** job that builds LLMinty, runs it at the repo root, and commits `minty.txt` back when it changes. Add this workflow at `.github/workflows/llminty.yml`:

```yaml
name: Refresh minty.txt

on:
  push:
    branches: [ main ]
  pull_request:

permissions:
  contents: write  # needed to push changes

jobs:
  llminty:
    runs-on: macos-14
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Print Swift toolchain
        run: swift --version

      - name: Build LLMinty
        run: swift build -c release

      - name: Generate minty.txt
        run: .build/release/llminty

      - name: Commit updated minty.txt (if changed)
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          file_pattern: minty.txt
          commit_message: "chore: refresh minty.txt"
```

### Alternatives

- **Artifacts instead of commits** (for PRs):
  ```yaml
  - name: Upload minty.txt
    uses: actions/upload-artifact@v4
    with:
      name: minty
      path: minty.txt
  ```

- **Branch‑only updates:** Guard the auto‑commit step to only run on `push` to `main`:
  ```yaml
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  ```

- **GitLab CI / Azure Pipelines:** Use a macOS runner and the same three steps: checkout → `swift build -c release` → run `llminty` → persist `minty.txt` (artifact or commit).

---

## License

Add your chosen license here (e.g., MIT).

