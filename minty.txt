FILE: Sources/llminty/IgnoreMatcher.swift

import Foundation
/// Minimal gitignore-like engine with globs (* ? **), dir-trailing '/', root-anchored '/' and negation '!'
/// Evaluation order: built-ins first (exclude bias), then user's .mintyignore (last match wins)
struct IgnoreMatcher {
struct Pattern {
let negated: Bool
let dirOnly: Bool
let anchorRoot: Bool
let raw: String
let segments: [String] // split on '/'
}
private let ordered: [Pattern]
init(builtInPatterns: [String], userFileText: String) throws {
var list: [Pattern] = []
for p in builtInPatterns {
if let pat = Self.parse(line: p) { list.append(pat) }
}
for line in userFileText.components(separatedBy: .newlines) {
if let pat = Self.parse(line: line) { list.append(pat) }
}
self.ordered = list
}
/// Parse a single ignore line into a compiled Pattern
private static func parse(line: String) -> Pattern? { ... }
/// Last-match-wins as in gitignore
func isIgnored(_ relativePath: String, isDirectory: Bool) -> Bool { ... }
private static func match(pattern p: Pattern, pathSegments: [String]) -> Bool { ... }
// '**' matches zero or more segments. '*' matches within a segment (no '/').
private static func matchFrom(patternSegs: [String], pathSegs: [String], startAt: Int) -> Bool { ... }
}
FILE: Sources/llminty/FileScanner.swift

import Foundation
enum FileKind {
case swift, json, text, binary, unknown
}
struct RepoFile {
let relativePath: String
let absoluteURL: URL
let isDirectory: Bool
let kind: FileKind
let size: UInt64
}
enum ScanLimits {
static let maxFileBytes: UInt64 = 2 * 1024 * 1024 // 2 MB per file cap
}
struct FileScanner {
let root: URL
let matcher: IgnoreMatcher
func scan() throws -> [RepoFile] { ... }
static func seemsBinary(url: URL) -> Bool {
guard let fh = try? FileHandle(forReadingFrom: url) else { return false }
defer { try? fh.close() }
let sampleSize = 2048
let data = try? fh.read(upToCount: sampleSize)
guard let d = data, !d.isEmpty else { return false }
// Heuristics:
// 1) any NUL byte -> binary
if d.contains(0) { return true }
// 2) ratio of non-printable (excluding \t\r\n) too high -> binary
var nonPrintable = 0
for b in d {
if b == 9 || b == 10 || b == 13 { continue } // \t \n \r
if b < 32 || b == 127 { nonPrintable += 1 }
}
let ratio = Double(nonPrintable) / Double(d.count)
return ratio > 0.30
}
}
private extension String {
func removingPrefix(_ p: String) -> String { ... }
/// Return a relative path string from the absolute root. Normalizes separators and removes leading slash.
func relativePath(from root: String) -> String { ... }
}
extension String {
/// Replace a base prefix with "", returning a normalized relative path (no leading slash).
func path(replacingBase base: String) -> String {
return self.relativePath(from: base)
}
}
FILE: Sources/llminty/SwiftAnalyzer.swift

import Foundation
import SwiftParser
import SwiftSyntax
// MARK: - Intermediate models
struct AnalyzedFile {
let file: RepoFile
let text: String
// Declarations in this file (type names)
var declaredTypes: Set<String>
// Public/open API weighted counts (protocols ×2)
var publicAPIScoreRaw: Int
// Referenced type identifiers (simple heuristic)
var referencedTypes: [String: Int] // name -> occurrences
// Cyclomatic complexity sum across functions (very rough)
var complexity: Int
// Heuristic: does this target declare @main or SwiftUI.App or have top-level code?
var isEntrypoint: Bool
// Outgoing edges to other repo files by relative path (inferred via simple symbol map)
var outgoingFileDeps: [String]
// Inbound count (how many other files reference this one)
var inboundRefCount: Int
}
// MARK: - Analyzer
final class SwiftAnalyzer {
func analyze(files: [RepoFile]) throws -> [AnalyzedFile] { ... }
private func analyzeSwift(file: RepoFile, text: String) -> AnalyzedFile { ... }
}
// MARK: - Collector with SwiftSyntax
private struct CollectorContext {
var declaredTypes: Set<String> = []
var publicAPIScoreRaw: Int = 0
var referencedTypes: [String: Int] = [:]
var complexity: Int = 0
var isEntrypoint: Bool = false
var importedModules: Set<String> = []
var hasTopLevelCode: Bool = false
}
private final class SwiftCollector: SyntaxVisitor {
private var ctx: UnsafeMutablePointer<CollectorContext>
private var typeStack: [String] = []
init(context: inout CollectorContext) {
self.ctx = withUnsafeMutablePointer(to: &context) { $0 }
super.init(viewMode: .sourceAccurate)
}
override func visit(_ node: ImportDeclSyntax) -> SyntaxVisitorContinueKind {
ctx.pointee.importedModules.insert(node.path.trimmedDescription)
return .visitChildren
}
override func visit(_ node: StructDeclSyntax) -> SyntaxVisitorContinueKind { ... }
override func visitPost(_ node: StructDeclSyntax)  { _ = typeStack.popLast() }
override func visit(_ node: ClassDeclSyntax) -> SyntaxVisitorContinueKind {
let name = node.name.text
ctx.pointee.declaredTypes.insert(name)
if node.modifiers.containsPublicOrOpen { ctx.pointee.publicAPIScoreRaw += 1 }
typeStack.append(name)
return .visitChildren
}
override func visitPost(_ node: ClassDeclSyntax)  { _ = typeStack.popLast() }
override func visit(_ node: EnumDeclSyntax) -> SyntaxVisitorContinueKind {
let name = node.name.text
ctx.pointee.declaredTypes.insert(name)
if node.modifiers.containsPublicOrOpen { ctx.pointee.publicAPIScoreRaw += 1 }
typeStack.append(name)
return .visitChildren
}
override func visitPost(_ node: EnumDeclSyntax)  { _ = typeStack.popLast() }
override func visit(_ node: ProtocolDeclSyntax) -> SyntaxVisitorContinueKind {
let name = node.name.text
ctx.pointee.declaredTypes.insert(name)
if node.modifiers.containsPublicOrOpen { ctx.pointee.publicAPIScoreRaw += 2 } // protocols weighted ×2
typeStack.append(name)
return .visitChildren
}
override func visitPost(_ node: ProtocolDeclSyntax)  { _ = typeStack.popLast() }
override func visit(_ node: AttributeSyntax) -> SyntaxVisitorContinueKind {
if node.attributeName.trimmedDescription == "main" {
ctx.pointee.isEntrypoint = true
}
return .visitChildren
}
override func visit(_ node: SourceFileSyntax) -> SyntaxVisitorContinueKind {
// Top-level code heuristic: any non-declaration item at file scope.
// CodeBlockItemSyntax.item is `Syntax`. If it's not a DeclSyntax, treat as top-level code.
for item in node.statements {
if item.item.as(DeclSyntax.self) == nil {
// Could be StmtSyntax or ExprSyntax -> treat as top-level code
ctx.pointee.hasTopLevelCode = true
break
}
}
return .visitChildren
}
override func visitPost(_ node: SourceFileSyntax)  {
if ctx.pointee.hasTopLevelCode { ctx.pointee.isEntrypoint = true }
}
// Types referenced (IdentifierTypeSyntax and MemberTypeSyntax roots)
override func visit(_ node: IdentifierTypeSyntax) -> SyntaxVisitorContinueKind {
let n = node.name.text
if !n.isEmpty {
ctx.pointee.referencedTypes[n, default: 0] += 1
}
return .visitChildren
}
override func visit(_ node: MemberTypeSyntax) -> SyntaxVisitorContinueKind {
// Count the base name only (Foo.Bar -> Foo)
let n = node.baseType.trimmedDescription
if !n.isEmpty {
ctx.pointee.referencedTypes[n, default: 0] += 1
}
return .visitChildren
}
// Complexity: count control-flow tokens and boolean ops
override func visit(_ token: TokenSyntax) -> SyntaxVisitorContinueKind { ... }
}
// MARK: - Small helpers
private extension DeclModifierListSyntax {
var containsPublicOrOpen: Bool {
for m in self {
let k = m.name.text
if k == "public" || k == "open" { return true }
}
return false
}
}
private extension Optional where Wrapped == DeclModifierListSyntax {
var containsPublicOrOpen: Bool { self?.containsPublicOrOpen ?? false }
}
private extension StructDeclSyntax {
func inheritanceClauseContains(type: String) -> Bool {
if let clause = self.inheritanceClause {
for inhe in clause.inheritedTypes {
if inhe.type.trimmedDescription == type { return true }
}
}
return false
}
}
FILE: Sources/llminty/Scoring.swift

import Foundation
struct ScoredFile {
let analyzed: AnalyzedFile
let score: Double
let fanIn: Int
let pageRank: Double
}
final class Scoring {
struct Norm {
var fanInMax = 0
var pageRankMax = 0.0
var apiMax = 0
var influenceMax = 0
var complexityMax = 0
}
/// Compute a composite [0,1] score for each file.
/// Heuristics balance inbound references, PageRank, public API surface, "influence"
/// (outgoing refs) and measured complexity; + entrypoint bonus.
func score(analyzed: [AnalyzedFile]) -> [ScoredFile] {
// Precompute PR and fan-in
let pr = GraphCentrality.pageRank(analyzed)
var fanIn: [String: Int] = [:]
for a in analyzed {
fanIn[a.file.relativePath] = a.inboundRefCount
}
// Collect maxima for normalization
var norm = Norm()
for a in analyzed {
norm.fanInMax = max(norm.fanInMax, fanIn[a.file.relativePath] ?? 0)
norm.pageRankMax = max(norm.pageRankMax, pr[a.file.relativePath] ?? 0.0)
norm.apiMax = max(norm.apiMax, a.publicAPIScoreRaw)
// "Influence": number of distinct outgoing file deps (fan-out)
norm.influenceMax = max(norm.influenceMax, a.outgoingFileDeps.count)
norm.complexityMax = max(norm.complexityMax, a.complexity)
}
// Safe division
func nzDiv(_ num: Double, by den: Double) -> Double { den == 0 ? 0 : (num / den) }
var out: [ScoredFile] = []
out.reserveCapacity(analyzed.count)
for a in analyzed {
let fanInN   = nzDiv(Double(fanIn[a.file.relativePath] ?? 0), by: Double(norm.fanInMax))
let prN      = nzDiv(pr[a.file.relativePath] ?? 0.0, by: norm.pageRankMax)
let apiN     = nzDiv(Double(a.publicAPIScoreRaw), by: Double(norm.apiMax))
let inflN    = nzDiv(Double(a.outgoingFileDeps.count), by: Double(norm.influenceMax))
let cxN      = nzDiv(Double(a.complexity), by: Double(norm.complexityMax))
let entry    = a.isEntrypoint ? 1.0 : 0.0
// Weights: 5 equally weighted primary signals + entrypoint bonus
let score =
0.18 * fanInN +
0.18 * prN +
0.18 * apiN +
0.18 * inflN +
0.18 * cxN +
0.10 * entry
out.append(
ScoredFile(
analyzed: a,
score: max(0.0, min(1.0, score)),
fanIn: fanIn[a.file.relativePath] ?? 0,
pageRank: pr[a.file.relativePath] ?? 0.0
)
)
}
return out
}
}
FILE: Sources/llminty/Rendering.swift

import Foundation
import SwiftParser
import SwiftSyntax
struct RenderedFile {
let relativePath: String
let content: String
}
final class Renderer {
func render(file: ScoredFile, score: Double) throws -> RenderedFile { ... }
// MARK: - Text compaction
/// For .text / .unknown: trim trailing spaces per line, collapse runs of blank lines to a single blank.
private func compactText(_ s: String) -> String { ... }
/// For Swift bodies we sometimes want a gentler pass.
private func lightlyCondenseWhitespace(_ s: String) -> String { ... }
// MARK: - Swift policies
enum SwiftPolicy {
case keepAllBodiesLightlyCondensed            // s ≥ 0.75
case keepPublicBodiesElideOthers              // 0.50 ≤ s < 0.75
case keepOneBodyPerTypeElideRest              // 0.25 ≤ s < 0.50
case signaturesOnly                           // s < 0.25
}
func policyFor(score: Double) -> SwiftPolicy { ... }
// MARK: - Swift rendering (mechanical elision)
/// Mechanically elide Swift bodies according to the policy (generic & deterministic).
/// - Keeps short bodies everywhere (thresholds below), and keeps the shortest body per type in the 0.25–0.50 bin.
func renderSwift(text: String, policy: SwiftPolicy) throws -> String {
struct Fn {
let range: Range<String.Index>      // full { ... } including braces
let bodyRange: Range<String.Index>  // interior text between braces
let isPublic: Bool
let typePath: [String]              // nesting types
let lines: Int
}
let src = text
// Total lines (for small-file exemption)
let totalLines: Int = {
var n = 1
for ch in src where ch == "\n" { n += 1 }
return n
}()
// --- thresholds (mechanical) ---
var shortKeepAllPolicies = 12
var shortKeepInSignOnly  = 5
if totalLines <= 120 {
// small-file exemption: be a bit more lenient
shortKeepAllPolicies = max(shortKeepAllPolicies, 16)
shortKeepInSignOnly  = max(shortKeepInSignOnly, 8)
}
// Scan once; maintain a type context stack using matched braces.
var fns: [Fn] = []
fns.reserveCapacity(64)
struct TypeCtx { let name: String; let end: String.Index }
var typeCtx: [TypeCtx] = []
@inline(__always)
func isIdent(_ c: Character) -> Bool { c.isLetter || c.isNumber || c == "_" }
func skipSpaces(_ i: String.Index) -> String.Index { ... }
func readWord(_ i: String.Index) -> (String, String.Index) { ... }
func matchBraces(from start: String.Index) -> String.Index? { ... }
func lineCount(in r: Range<String.Index>) -> Int { ... }
var i = src.startIndex
while i < src.endIndex {
// pop expired type contexts
while let last = typeCtx.last, i >= last.end { _ = typeCtx.popLast() }
if src[i].isWhitespace {
i = src.index(after: i); continue
}
// gather modifiers
var j = i
var modifiers: [String] = []
let knownMods: Set<String> = ["public","open","internal","private","fileprivate","static","class","final","mutating","nonmutating","override"]
while j < src.endIndex {
j = skipSpaces(j)
let (w, afterW) = readWord(j)
if w.isEmpty || !knownMods.contains(w) { break }
modifiers.append(w)
j = afterW
}
// keyword after modifiers
let (kw, afterKW) = readWord(j)
if kw == "struct" || kw == "class" || kw == "enum" || kw == "protocol" {
var nameStart = afterKW
nameStart = skipSpaces(nameStart)
let (name, afterName) = readWord(nameStart)
var k = afterName
while k < src.endIndex, src[k] != "{" { k = src.index(after: k) }
if k < src.endIndex, src[k] == "{", let end = matchBraces(from: k) {
let endPlusOne = src.index(after: end)
typeCtx.append(.init(name: name.isEmpty ? "<anon>" : name, end: endPlusOne))
i = src.index(after: k)
continue
}
i = afterName
continue
}
if kw == "func" || kw == "init" || kw == "subscript" { ... }
}
// MARK: - Small helpers (parity with existing structure)
private extension String {
func trimRightSpaces() -> String { ... }
}
private extension DeclModifierListSyntax {
var containsPublicOrOpen: Bool {
for m in self {
let k = m.name.text
if k == "public" || k == "open" { return true }
}
return false
}
}
private extension Optional where Wrapped == DeclModifierListSyntax {
var containsPublicOrOpen: Bool { self?.containsPublicOrOpen ?? false }
}
FILE: Sources/llminty/App.swift

import Foundation
enum BuiltInExcludes {
static func defaultPatterns(outputFileName: String) -> [String] {
// Users can re-include via .mintyignore negation (!)
return [
// VCS / editor
".git/", ".gitignore", ".gitattributes", ".DS_Store", ".idea/", ".vscode/", ".svn/", ".hg/",
// SwiftPM
".build/", ".swiftpm/",
// Xcode
"DerivedData/", "*.xcodeproj/", "*.xcworkspace/", "xcuserdata/",
// Apple bundles/outputs
"*.app/", "*.appex/", "*.framework/", "*.dSYM/", "*.xcarchive/",
// Dependency managers
"Pods/", "Carthage/",
// Assets / binary noise (wide net by default)
"*.xcassets/", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.heic", "*.pdf",
"*.svg", "*.webp", "*.ttf", "*.otf", "*.woff", "*.woff2",
"*.zip", "*.tar", "*.tar.gz", "*.rar", "*.7z",
"*.mp3", "*.wav", "*.aiff", "*.m4a", "*.mp4", "*.mov",
"*.bin", "*.dat",
// Self-exclude
outputFileName
]
}
}
/// Aggressively trims blank lines for final output while keeping exactly one
/// blank line after each "FILE: " header. Also:
/// - trims trailing spaces,
/// - collapses 3+ newlines to 2 during pre-pass,
/// - removes all other blank-only lines.
/// Returns a string that always ends with a single trailing newline.
func postProcessMinty(_ s: String) -> String { ... }
public struct LLMintyApp {
public init() {}
public func run() throws { ... }
}
private extension String {
func trimRightSpaces() -> String {
var s = self
while s.last == " " { _ = s.removeLast() }
return s
}
}
FILE: Sources/llminty/GraphCentrality.swift

import Foundation
enum GraphCentrality {
// PageRank on file dependency graph (A -> B means A depends on B)
static func pageRank(_ analyzed: [AnalyzedFile],
damping: Double = 0.85,
iterations: Int = 20) -> [String: Double] {
let files: [String] = analyzed.map { $0.file.relativePath }
let index: [String: Int] = Dictionary(uniqueKeysWithValues: files.enumerated().map { ($1, $0) })
let n = files.count
guard n > 0 else { return [:] }
// Outgoing edges (by index)
var outEdges: [Set<Int>] = Array(repeating: [], count: n)
for a in analyzed {
let i = index[a.file.relativePath]!
for dep in a.outgoingFileDeps {
if let j = index[dep] { outEdges[i].insert(j) }
}
}
// Init PR
var pr = Array(repeating: 1.0 / Double(n), count: n)
var newPR = Array(repeating: 0.0, count: n)
let base = (1.0 - damping) / Double(n)
for _ in 0..<iterations {
// Distribute rank
for i in 0..<n { newPR[i] = base }
for i in 0..<n {
let outs = outEdges[i]
if outs.isEmpty {
// Dangling node: spread evenly
let share = damping * pr[i] / Double(n)
for j in 0..<n { newPR[j] += share }
} else {
let share = damping * pr[i] / Double(outs.count)
for j in outs { newPR[j] += share }
}
}
pr = newPR
}
// Map back to paths
var out: [String: Double] = [:]
for (p, i) in index { out[p] = pr[i] }
return out
}
/// Dependency-aware emission order:
/// If A depends on B, emit B before A. When multiple nodes are available,
/// prefer higher score, then lexicographic path.
static func orderDependencyAware(_ scored: [ScoredFile]) -> [ScoredFile] {
let nodes: [String] = scored.map { $0.analyzed.file.relativePath }
let idx: [String: Int] = Dictionary(uniqueKeysWithValues: nodes.enumerated().map { ($1, $0) })
// Build graph with edges B -> A if A depends on B
var inDegree = Array(repeating: 0, count: nodes.count)
var adj: [Set<Int>] = Array(repeating: [], count: nodes.count)
for (aIndex, s) in scored.enumerated() {
for depPath in s.analyzed.outgoingFileDeps {
if let bIndex = idx[depPath] {
// Edge: dep (B) -> this (A)
if !adj[bIndex].contains(aIndex) {
adj[bIndex].insert(aIndex)
inDegree[aIndex] += 1
}
}
}
}
// Min-heap-ish queue by (-score, path) to prefer higher score first among zero in-degree
func heapSort(_ arr: [Int]) -> [Int] {
return arr.sorted { i, j in
let si = scored[i], sj = scored[j]
if si.score != sj.score { return si.score > sj.score }
return si.analyzed.file.relativePath < sj.analyzed.file.relativePath
}
}
var queue = heapSort((0..<nodes.count).filter { inDegree[$0] == 0 })
var out: [ScoredFile] = []
while !queue.isEmpty {
let v = queue.removeFirst()
out.append(scored[v])
for u in adj[v] {
inDegree[u] -= 1
if inDegree[u] == 0 {
// insert keeping queue sorted
let pos = queue.firstIndex(where: { i in
let si = scored[u], sj = scored[i]
if si.score != sj.score { return si.score > sj.score }
return si.analyzed.file.relativePath < sj.analyzed.file.relativePath
}) ?? queue.endIndex
queue.insert(u, at: pos)
}
}
}
// Cycles: append remaining deterministically by score then path
if out.count < scored.count {
let placed = Set(out.map { $0.analyzed.file.relativePath })
let remaining = scored.filter { !placed.contains($0.analyzed.file.relativePath) }
let sortedRem = remaining.sorted {
if $0.score != $1.score { return $0.score > $1.score }
return $0.analyzed.file.relativePath < $1.analyzed.file.relativePath
}
out.append(contentsOf: sortedRem)
}
return out
}
}
FILE: Tests/LLMintyTests/GraphCentralityTests.swift

import XCTest
@testable import llminty
final class GraphCentralityTests: XCTestCase {
private func analyzed(_ path: String, deps: [String]) -> AnalyzedFile { ... }
func testDependencyAwareOrder() { ... }
}
FILE: Sources/llminty/main.swift

import Foundation
// Top-level entrypoint for the executable target.
// (Do NOT use @main if the module has any other top-level code.)
do {
try LLMintyApp().run()
} catch {
fputs("llminty: \(error.localizedDescription)\n", stderr)
exit(1)
}
FILE: Tests/LLMintyTests/SwiftAnalyzerTests.swift

import XCTest
@testable import llminty
final class SwiftAnalyzerTests: XCTestCase {
func testEntrypointPublicAPIAndRefs() throws { ... }
}
FILE: Sources/llminty/JSONReducer.swift

import Foundation
enum JSONReducer {
// Head/Tail sample sizes
private static let head = 3
private static let tail = 2
private static let dictKeep = 6
static func reduceJSONPreservingStructure(text: String) -> String {
guard let data = text.data(using: .utf8) else { return text }
let obj = try? JSONSerialization.jsonObject(with: data, options: [])
guard let json = obj else { return text } // pass-through on invalid JSON
let reduced = reduce(json, seen: [])
return stringify(reduced)
}
private static func reduce(_ v: Any, seen: Set<ObjectIdentifier>) -> Any {
if let a = v as? [Any] { return reduceArray(a, seen: seen) }
if let d = v as? [String: Any] { return reduceDict(d, seen: seen) }
return v
}
private static func reduceArray(_ a: [Any], seen: Set<ObjectIdentifier>) -> Any { ... }
private static func reduceDict(_ d: [String: Any], seen: Set<ObjectIdentifier>) -> Any { ... }
private static func stringify(_ v: Any) -> String { ... }
private static func escape(_ s: String) -> String { ... }
}
FILE: Tests/LLMintyTests/LLMintyTests.swift

import XCTest
@testable import llminty
final class LLMintyTests: XCTestCase {
// End-to-end: builds a mini project, runs the app, checks minty.txt framing and ignore behavior.
func testEndToEndRunCreatesMintyFile() throws { ... }
// Compaction policy: keep exactly one blank line after each FILE header, drop others,
// but allow a single terminal blank line (trailing newline in the file).
func testKeepsOneBlankAfterHeadersAndDropsOthers() { ... }
}
FILE: Tests/LLMintyTests/RenderingTests.swift

import XCTest
@testable import llminty
final class RenderingTests: XCTestCase {
func testPolicyForThresholds() {
let r = Renderer()
// Original bins
XCTAssertEqual(r.policyFor(score: 0.80), .keepAllBodiesLightlyCondensed)
XCTAssertEqual(r.policyFor(score: 0.60), .keepPublicBodiesElideOthers)
XCTAssertEqual(r.policyFor(score: 0.30), .keepOneBodyPerTypeElideRest)
XCTAssertEqual(r.policyFor(score: 0.10), .signaturesOnly)
}
func testRenderSwiftElidesNonPublicBodiesUnderPolicy() throws { ... }
func testRenderTextCompactsWhitespace() throws { ... }
}
FILE: Tests/LLMintyTests/ScoringTests.swift

import XCTest
@testable import llminty
final class ScoringTests: XCTestCase {
func testScoringWeightsAndEntrypointBonus() { ... }
}
FILE: Package.swift

// swift-tools-version: 6.0
import PackageDescription
let package = Package(
name: "LLMinty",
platforms: [
.macOS(.v13)
],
products: [
.executable(name: "llminty", targets: ["llminty"])
],
dependencies: [
// Match your Swift 6.1 toolchain. 601.x == SwiftSyntax for Swift 6.1
.package(url: "https://github.com/swiftlang/swift-syntax.git", exact: "601.0.1")
],
targets: [
.executableTarget(
name: "llminty",
dependencies: [
.product(name: "SwiftParser", package: "swift-syntax"),
.product(name: "SwiftSyntax", package: "swift-syntax")
],
path: "Sources/llminty"
),
.testTarget(
name: "LLMintyTests",
dependencies: ["llminty"],
path: "Tests/LLMintyTests"
)
]
)
FILE: Tests/LLMintyTests/FileScannerTests.swift

// Tests/LLMintyTests/FileScannerTests.swift
import XCTest
@testable import llminty
final class FileScannerTests: XCTestCase {
func testScanningKindsAndIgnores() throws { ... }
}
FILE: Tests/LLMintyTests/IgnoreMatcherTests.swift

import XCTest
@testable import llminty
final class IgnoreMatcherTests: XCTestCase {
func testGlobAnchorsAndNegation() throws { ... }
}
FILE: Tests/LLMintyTests/JSONReducerTests.swift

import XCTest
@testable import llminty
final class JSONReducerTests: XCTestCase {
func testArrayAndDictReduction() { ... }
func testPassThroughOnInvalidJSON() {
let notJSON = "hello"
let out = JSONReducer.reduceJSONPreservingStructure(text: notJSON)
XCTAssertEqual(out, notJSON)
}
}
